<html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Try to save my life"><meta name="keyword"><title>UE_AnimationSystem
-
小禾苗の垃圾堆
-

</title><link rel="icon" href="/img/favicon.ico">
<link rel="stylesheet" href="/css/style.css">

<link rel="stylesheet" href="/css/helpers.css">

<script src="/js/clipboard/clipboard.min.js"></script>


<script src="/js/bootstrap.js"></script>

<script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><!-- hexo injector head_end start --><style>
body hanla:after {
    content: ' ';
    display: inline;
    font-family: inherit;
    font-size: 0.45em;
}

html code hanla,
html pre hanla,
html kbd hanla,
html samp hanla,
html ruby hanla,
html .tag-list-item hanla {
    display: none;
}

html ol > hanla,
html ul > hanla {
    display: none;
}
</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading-wrapper" data-loading="data-loading"><div class="loading"><span></span><span></span><span></span></div></div><div class="page" data-filter="data-filter"><div class="head" data-show="data-show"><header class="head-header"><div class="head-author"><a class="head-author-link" href="/">小禾苗の垃圾堆<hanla></hanla></a></div><div class="head-right"><button class="bar-wrap" id="bar-wrap-toggle" title="menu button"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button><div class="head-item"><a class="search-button head-item-link"><span>Search</span>
<i class="icon icon-search"></i></a></div><div class="head-item"><a class="head-item-link" href="/about">关于</a></div></div></header>
<div class="menubar-head" id="menubar"><ul class="menubar-ul"><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><i class="icon icon-archive"></i>
<a class="menubar-link" href="/archives">Archives</a></li><li class="menubar-item"><i class="icon icon-tags"></i>
<a class="menubar-link" href="/tags">Tags</a></li><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><a class="menubar-link" href="/about"><span><hanla></hanla>关于<hanla></hanla></span></a></li></ul><div class="menu-search-box search-button"><div>Search</div>
<i class="icon icon-search"></i></div></div></div><div class="main" data-page="post"><article class="post" id="post"><header class="post-head"><h1 class="post-title"><a class="title" href="/2024/12/05/UE_AnimationSystem/">UE_AnimationSystem</a></h1></header><div class="post-meta"><div class="post-date"><time class="post-time" itemprop="datePublished" title="2024-12-05 20:31:13" datetime="2024-12-05T12:31:13.000Z">2024-12-05</time></div>|
<div class="post-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UE/" rel="tag">UE</a></li></ul></div>
<div class="post-visit"><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span>hits</span></div></div><div class="post-info"><div class="post-word-count">This article contains 5,545 words.</div>
</div><div class="article-entry" itemprop="articleBody"><h2 id="UE-动画系统-Copy"><a href="#UE-动画系统-Copy" class="headerlink" title="UE 动画系统 Copy"></a>UE 动画系统 Copy</h2><h3 id="动画基础"><a href="#动画基础" class="headerlink" title="动画基础"></a><hanla></hanla>动画基础</h3><h4 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h4><p>优点：记录每一帧，拥有最高的自由度；</p>
<p>缺点：要记录的信息非常多，常见应用情景：人物表情、捏脸等</p>
<h4 id="骨骼动画"><a href="#骨骼动画" class="headerlink" title="骨骼动画"></a>骨骼动画</h4><p>记录骨骼的 transform 信息，在程序运行过程中，根据骨骼当前位置计算出真正的顶点的位置信息</p>
<p>记录每个顶点绑定的是哪个骨骼和相对位置</p>
<p>骨骼树中，每一个记录的都是相对其父节点的位置，所以要获得世界坐标，就需要一层层的计算上去</p>
<blockquote>
<p>渲染这一套是根据上面两个信息拿到空间矩阵？</p>
<img src="/2024/12/05/UE_AnimationSystem/Yj7Kb5OBfoPjJzxoKpmcqGfpnrc.png" class="" title="aaa">
<img src="/2024/12/05/UE_AnimationSystem/KqhFbhEUooQcYLxgxanceeeWndo.png" class="" title="bbb">
<p>Cite: game104</p>
</blockquote>
<img src="/2024/12/05/UE_AnimationSystem/CC3oblmgIoVdRMxGe51cMB9Un9s.png" class="" title="ccc">

<img src="/2024/12/05/UE_AnimationSystem/Bc5rb3pjto2ghsxYy2McqxpQnKh.png" class="" title="ddd">

<blockquote>
<p>首先，对于骨骼动画来说，他的运动趋势实际上是不会频繁变化的<br>所以对于满帧的数据而言，在容许一定容差的前提下，其可以通过在其中将若干帧数据提取为关键帧，然后其他帧借助线性插值的方式来生成<br>这个算法要解决的主要问题是如何从满帧的骨骼动画数据中，再给定容差的前提下，提取出关键帧。主要优点是生成的数据依旧是关键帧数据，所以不需要改变原本的文件格式与接口，兼容性较好<br>首先给定一个计算关键帧之间的差的函数 f，对于大多数骨骼动画而言，其主要动画以旋转为主，所以这里 f 取骨骼中三个角度差的平方和，作为 f，给定误差累计阈值 k，对于任意一个骨骼 bonei，以及其满帧数据 bonei0，bonei1… bonein<br><hanla></hanla>首先将 bonei0 加入关键帧列表中，然后从 bonei0 开始向后步进，对每次步进到的 boneim，我们做这样的运算<br>首先我们<hanla></hanla>“假定”boneim 为关键帧<br>接下来我们根据 bonei0 与 boneim，以插值的方式生成一组满帧的数据，计为 bonei0%，bonei1%，。。。boneim%<br><hanla></hanla>然后对将 bonei0% 与 bonei0；bonei1% 与 bonei1。。。boneim 与 boneim% 做之前提到的 f 运算，得到一组误差值，将其累加起来，计为 km，当我们步进到第一个 km，其使得 km＞k（误差累计阈值）时，将第 m-1 帧的数据，bonem-1 记录到关键帧列表中，接下来就是 bonem-1 开始向后步进，将 bonem-1 和后面的帧去做上面的插值与误差累计计算，从而找到全部能使得累计误差小于误差累计阈值 k 的关键帧，然后最后一帧别忘了也丢进去<br>再是针对这次需求的算法改进，如果需要考虑客户端与服务器延迟，那么可以在这一步额外增加校验，如果两帧之间的差（时间上的差）大于给定的延迟阈值，那么即使误差累积函数没有达到要求，也将其记录到关键帧列表中并发送<br>几个注意点是，这个算法可以在每个骨骼上分开运行，所以在大部分帧上，并不会记录全部的骨骼关键帧，这个对你的数据同步带宽上可能会有帮助，但在写同步代码的时候可能要注意<br>另一个是尽量走父骨骼空间的位置旋转去做 f 运算，这样压缩效果一般更好，用世界空间的话估计压缩效果锐减</p>
</blockquote>
<h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><h4 id="骨骼模型基础信息"><a href="#骨骼模型基础信息" class="headerlink" title="骨骼模型基础信息"></a>骨骼模型基础信息<hanla></hanla></h4><p>UE 里，一个模型就是一个 <code>SkeletalMesh</code></p>
<p><code>SkeletalMesh</code> 类下有 <code>FSkeletalMeshRenderData</code></p>
<p><code>FSkeletalMeshRenderData</code> 第一层有 <code>FSkeletalMeshLODRenderData</code> 区分</p>
<p><code>FSkeletalMeshLODRenderData</code> 下又有 <code>StaticVertexBuffers</code>; <code>SkinWeightVertexBuffer</code> 这些已经处理好的数据，原始的数据则在</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line">    _<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_     * Initialize render data (e.g. vertex buffers) from model info_</span></span><br><span class="line"><span class="comment">_     * @param InLODModel The model to build the render data from._</span></span><br><span class="line"><span class="comment">_     * @param InVertexAttributeInfos The vertex attributes to possibly include and their stored data type._</span></span><br><span class="line"><span class="comment">_     * @param InBuildFlags See ESkeletalMeshVertexFlags._</span></span><br><span class="line"><span class="comment">_     */</span><span class="function">_</span></span><br><span class="line"><span class="function">_    _void ENGINE_API <span class="title">BuildFromLODModel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> FSkeletalMeshLODModel* InLODModel,</span></span></span><br><span class="line"><span class="params"><span class="function">       TConstArrayView&lt;FSkeletalMeshVertexAttributeInfo&gt; InVertexAttributeInfos = {},</span></span></span><br><span class="line"><span class="params"><span class="function">       ESkeletalMeshVertexFlags InBuildFlags = ESkeletalMeshVertexFlags::None</span></span></span><br><span class="line"><span class="params"><span class="function">       )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> _<span class="comment">// WITH_EDITOR_ ```</span></span></span><br></pre></td></tr></tbody></table></figure>

<p><code>LODModel</code> 又将 Mesh 分成很多 <code>SkelMeshSection</code>，每个 <code>Section</code> 里面又存放很多信息，包括 <code>SoftSkinVertex</code>(5.3 中没在 <code>Section</code> 类中找到，但是文件中仍然存在，新版这个没看懂是 <code>BaseVertexIndex</code> 还是 <code>FMeshToMeshVertData</code>)，然后一组顶点构成一个 <code>Section</code></p>
<p>骨骼的类 <code>USkeleton</code>，5.1 以后用的是 <code>FReferenceSkeleton</code>，里面包含骨骼所有的信息，<code>FMeshBoneInfo</code>、<code>FTransform</code></p>
<h4 id="动画序列"><a href="#动画序列" class="headerlink" title="动画序列"></a>动画序列<hanla></hanla></h4><p>Animation Sequence 存储所有的骨骼在每一帧的 <code>Transform</code> 信息</p>
<p><code>UAnimSequence</code> 里，原始动画数据很大，他自己有做一个 <code>FCompressedAnimSequence</code>，在用的时候再提取出来，这里的压缩算法后面再解释。</p>
<p>还有一个 <code>FBoneAnimationTrack</code>，存储一根骨骼所有帧的信息，包含 <code>FRawAnimSequenceTrack</code></p>
<p>每一帧的数据用 <code>GetBonePose</code>，根据时间算出两个索引？</p>
<p><code>BuildPoseFromModel</code> 从 DataModel 提取出 OutPose，再传入时间（根据时间，找出两帧的索引，再做一个插值）。如果是打包以后，就会有一个 <code>DecompressPose</code> 先去提取数据（提取哪些，要补充一下具体的内容）</p>
<h4 id="动画信息"><a href="#动画信息" class="headerlink" title="动画信息"></a>动画信息</h4><p>导入的 fbx 会自动转成 <code>AnimSequenece</code></p>
<p><code>AnimSequence</code> 有一个基类 <code>AnimSequenceBase</code>，里面有一个指针指向 <code>UAnimDataModel</code>，</p>
<p><code>UAnimDataModel</code> 里包含了动画的一些原始信息，包含动画的长度、帧率等，也有一个 <code>FBoneAnimationTrack</code></p>
<h4 id="动画蓝图如何更新动画"><a href="#动画蓝图如何更新动画" class="headerlink" title="动画蓝图如何更新动画"></a>动画蓝图如何更新动画</h4><p>在 <code>Character</code> 中，我们会挂载一个 <code>USkeletalMeshComponent</code> 绑定角色模型，而在这个类中，又有 <code>UAnimInstance</code> 驱动动画，<code>UAnimInstance</code> 下用 <code>FAnimInstanceProxy</code> 代理类实现多线程的更新</p>
<p><code>USkeletalMeshComponent</code> 有一个父类 <code>USkinnedMeshComponent</code>，在他的 <code>TickComponent</code> 中，我们会去调用 <code>DispatchParallelTickPose</code> 更新动画，<code>DispatchParallelTickPose</code> 是虚函数，所以最后还是 <code>USkeletalMeshComponent</code> 的 <code>DispatchParallelTickPose</code> 完成具体的实现。</p>
<p><code>USkeletalMeshComponent</code> 的 <code>DispatchParallelTickPose</code> 中，会有一个判断</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bDoParallelUpdate)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 执行多线程更新</span></span><br><span class="line">    <span class="built_in">DispatchParallelEvaluationTasks</span>(TickFunction);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    _<span class="comment">// we cant update on a worker thread, so perform the work here_</span></span><br><span class="line">_    _DoParallelEvaluationTasks_OnGameThread(); <span class="comment">// 只在主线程更新</span></span><br><span class="line">    <span class="built_in">PostAnimEvaluation</span>(AnimEvaluationContext);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>DispatchParallelEvaluationTasks</code> 内部也不是直接更新，而是使用</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">// start parallel work_</span></span><br><span class="line"><span class="built_in">check</span>(!<span class="built_in">IsValidRef</span>(ParallelAnimationEvaluationTask));</span><br><span class="line">ParallelAnimationEvaluationTask = TGraphTask&lt;FParallelAnimationEvaluationTask&gt;::<span class="built_in">CreateTask</span>().<span class="built_in">ConstructAndDispatchWhenReady</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>创建一个 <code>FParallelAnimationEvaluationTask</code>，然后放在多线程里面去执行</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">// set up a task to run on the game thread to accept the results_</span></span><br><span class="line">FGraphEventArray Prerequistes;</span><br><span class="line">Prerequistes.<span class="built_in">Add</span>(ParallelAnimationEvaluationTask);</span><br><span class="line">FGraphEventRef TickCompletionEvent = TGraphTask&lt;FParallelAnimationCompletionTask&gt;::<span class="built_in">CreateTask</span>(&amp;Prerequistes).<span class="built_in">ConstructAndDispatchWhenReady</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>这个 <code>Task</code> 只是一个辅助的作用，在 <code>DoTask</code> 里，又会反过来调用 <code>USkeletalMeshComponent</code> 的 <code>ParallelAnimationEvaluation</code>，如果之前是 <code>DoParallelEvaluationTasks_OnGameThread</code> 主线程更新，会直接调用 <code>ParallelAnimationEvaluation</code>，不走 <code>Task</code> 了</p>
<p><code>ParallelAnimationEvaluation</code> 函数中，就有 <code>PerformAnimationProcessing</code> 处理动画，分成两个重要的步骤，第一，使用 <code>ParallelUpdateAnimation</code> 更新 <code>AnimInstance</code>；第二，使用 <code>EvaluateAnimation</code> 真正去计算 Pose。</p>
<p><code>ParallelUpdateAnimation</code> 用来计算动画相关的参数，例如 Blend 参数。</p>
<p>计算完成后，使用 <code>EvaluateAnimation</code> 提取出 Pose（在 Sequence 章节中有 <code>GetBonePose</code>，根据时间提取出两帧的骨骼的信息，看要不要做插值），具体执行流程为 <code>EvaluateAnimation</code> 调用 <code>AnimInstance</code> 的 <code>ParallelEvaluateAnimation</code>，再使用 <code>Proxy</code> 调用 <code>EvaluateAnimation</code>，到这一步，就能深入一层，调用到 <code>EvaluateAnimation_WithRoot</code> 了，这里就开始回溯，从根节点开始更新每个节点，<code>EvaluateAnimationNode_WithRoot</code>，最终调用到 <code>FAnimNode_Base</code> 的 <code>Evaluate_AnyThread</code></p>
<p><code>FAnimNode_Base</code> 中有 <code>GetEvaluateGraphExposedInputs().Execute(Context)</code> 递归找出蓝图中连起来的输入节点，触发更新</p>
<p>动画蓝图里每个节点最后都是继承自 <code>FAnimNode_Base</code>，所以都会有两个重要的虚函数，一个是 <code>Updatexxxx</code>，一个是 <code>Evaluatexxxx</code></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FAnimNode_SequencePlayerBase::UpdateAssetPlayer</span><span class="params">(<span class="type">const</span> FAnimationUpdateContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">DECLARE_SCOPE_HIERARCHICAL_COUNTER_ANIMNODE</span>(UpdateAssetPlayer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GetEvaluateGraphExposedInputs</span>().<span class="built_in">Execute</span>(Context);</span><br><span class="line"></span><br><span class="line">    UAnimSequenceBase* CurrentSequence = <span class="built_in">GetSequence</span>();</span><br><span class="line">    <span class="keyword">if</span> (CurrentSequence &amp;&amp; !<span class="built_in">ensureMsgf</span>(!CurrentSequence-&gt;<span class="built_in">IsA</span>&lt;UAnimMontage&gt;(), <span class="built_in">TEXT</span>(<span class="string">"Sequence players do not support anim montages."</span>)))</span><br><span class="line">    {</span><br><span class="line">       CurrentSequence = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CurrentSequence != <span class="literal">nullptr</span> &amp;&amp; CurrentSequence-&gt;<span class="built_in">GetSkeleton</span>() != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">       <span class="type">const</span> <span class="type">float</span> CurrentPlayRate = <span class="built_in">GetPlayRate</span>();</span><br><span class="line">       <span class="type">const</span> <span class="type">float</span> CurrentPlayRateBasis = <span class="built_in">GetPlayRateBasis</span>();</span><br><span class="line"></span><br><span class="line">       InternalTimeAccumulator = FMath::<span class="built_in">Clamp</span>(InternalTimeAccumulator, <span class="number">0.f</span>, CurrentSequence-&gt;<span class="built_in">GetPlayLength</span>());</span><br><span class="line">       <span class="type">const</span> <span class="type">float</span> AdjustedPlayRate = PlayRateScaleBiasClampState.<span class="built_in">ApplyTo</span>(<span class="built_in">GetPlayRateScaleBiasClampConstants</span>(), FMath::<span class="built_in">IsNearlyZero</span>(CurrentPlayRateBasis) ? <span class="number">0.f</span> : (CurrentPlayRate / CurrentPlayRateBasis), Context.<span class="built_in">GetDeltaTime</span>());</span><br><span class="line">       <span class="built_in">CreateTickRecordForNode</span>(Context, CurrentSequence, <span class="built_in">IsLooping</span>(), AdjustedPlayRate, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITORONLY_DATA</span></span><br><span class="line">    <span class="keyword">if</span> (FAnimBlueprintDebugData* DebugData = Context.AnimInstanceProxy-&gt;<span class="built_in">GetAnimBlueprintDebugData</span>())</span><br><span class="line">    {</span><br><span class="line">       DebugData-&gt;<span class="built_in">RecordSequencePlayer</span>(Context.<span class="built_in">GetCurrentNodeId</span>(), <span class="built_in">GetAccumulatedTime</span>(), CurrentSequence != <span class="literal">nullptr</span> ? CurrentSequence-&gt;<span class="built_in">GetPlayLength</span>() : <span class="number">0.0f</span>, CurrentSequence != <span class="literal">nullptr</span> ? CurrentSequence-&gt;<span class="built_in">GetNumberOfSampledKeys</span>() : <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">TRACE_ANIM_SEQUENCE_PLAYER</span>(Context, *<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">TRACE_ANIM_NODE_VALUE</span>(Context, <span class="built_in">TEXT</span>(<span class="string">"Name"</span>), CurrentSequence != <span class="literal">nullptr</span> ? CurrentSequence-&gt;<span class="built_in">GetFName</span>() : NAME_None);</span><br><span class="line">    <span class="built_in">TRACE_ANIM_NODE_VALUE</span>(Context, <span class="built_in">TEXT</span>(<span class="string">"Asset"</span>), CurrentSequence);</span><br><span class="line">    <span class="built_in">TRACE_ANIM_NODE_VALUE</span>(Context, <span class="built_in">TEXT</span>(<span class="string">"Playback Time"</span>), InternalTimeAccumulator);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FAnimNode_SequencePlayerBase::Evaluate_AnyThread</span><span class="params">(FPoseContext&amp; Output)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">DECLARE_SCOPE_HIERARCHICAL_COUNTER_ANIMNODE</span>(Evaluate_AnyThread);</span><br><span class="line"></span><br><span class="line">    UAnimSequenceBase* CurrentSequence = <span class="built_in">GetSequence</span>();</span><br><span class="line">    <span class="keyword">if</span> (CurrentSequence != <span class="literal">nullptr</span> &amp;&amp; CurrentSequence-&gt;<span class="built_in">GetSkeleton</span>() != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">       <span class="type">const</span> <span class="type">bool</span> bExpectedAdditive = Output.<span class="built_in">ExpectsAdditivePose</span>();</span><br><span class="line">       <span class="type">const</span> <span class="type">bool</span> bIsAdditive = CurrentSequence-&gt;<span class="built_in">IsValidAdditive</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (bExpectedAdditive &amp;&amp; !bIsAdditive)</span><br><span class="line">       {</span><br><span class="line">          FText Message = FText::<span class="built_in">Format</span>(<span class="built_in">LOCTEXT</span>(<span class="string">"AdditiveMismatchWarning"</span>, <span class="string">"Trying to play a non-additive animation '{0}' into a pose that is expected to be additive in anim instance '{1}'"</span>), FText::<span class="built_in">FromString</span>(CurrentSequence-&gt;<span class="built_in">GetName</span>()), FText::<span class="built_in">FromString</span>(Output.AnimInstanceProxy-&gt;<span class="built_in">GetAnimInstanceName</span>()));</span><br><span class="line">          Output.<span class="built_in">LogMessage</span>(EMessageSeverity::Warning, Message);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="function">FAnimationPoseData <span class="title">AnimationPoseData</span><span class="params">(Output)</span></span>;</span><br><span class="line">       CurrentSequence-&gt;<span class="built_in">GetAnimationPose</span>(AnimationPoseData, <span class="built_in">FAnimExtractContext</span>(<span class="built_in">UE_AnimationSystem_cast</span>&lt;<span class="type">double</span>&gt;(InternalTimeAccumulator), Output.AnimInstanceProxy-&gt;<span class="built_in">ShouldExtractRootMotion</span>(), DeltaTimeRecord, <span class="built_in">IsLooping</span>()));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">       Output.<span class="built_in">ResetToRefPose</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="蒙太奇源码分析"><a href="#蒙太奇源码分析" class="headerlink" title="蒙太奇源码分析"></a><hanla></hanla>蒙太奇源码分析<hanla></hanla></h4><p><code>UAnimMontage</code> 类里存的动画片段是 <code>FCompositeSection</code></p>
<p>Slot 则是 <code>FSlotAnimationTrack</code>，每个 Track 里有 <code>SlotName</code> 和 <code>FAnimTrack</code>，<code>FAnimTrack</code> 里的是 <code>FAnimSegment</code>，然后这里面又包括 <code>UAnimSequenceBase</code>，最后就是 <code>FRawCurveTracks</code> 和 <code>FAnimNotifyTrack</code> 了</p>
<p>出发点我们从 <code>UAnimInstance</code> 里 <code>Montage_Play</code> 开始，跳转到 <code>Montage_PlayInternal</code>，创建一个蒙太奇实例，初始化相关数据，添加到一个包含所有的蒙太奇的数组里，到时候每一帧更新都会找到该数组进行更新</p>
<p>更新也是和之前一样，从 <code>Tick</code> 里一直调用到 <code>UpdateMontage</code>，先用 <code>Montage_UpdateWeight</code> 更新相关数据，再用 <code>Montage_Advance</code> 更新 DeltaSeconds</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">// update montage weight_</span></span><br><span class="line"><span class="built_in">Montage_UpdateWeight</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">_<span class="comment">// update montage should run in game thread_</span></span><br><span class="line">_<span class="comment">// if we do multi threading, make sure this stays in game thread. _</span></span><br><span class="line">_<span class="comment">// This is because branch points need to execute arbitrary code inside this call._</span></span><br><span class="line"><span class="built_in">Montage_Advance</span>(DeltaSeconds);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAnimInstance::Montage_UpdateWeight</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (MontageInstances.<span class="built_in">IsEmpty</span>())</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_Montage_UpdateWeight);</span><br><span class="line"></span><br><span class="line">    _<span class="comment">// go through all montage instances, and update them_</span></span><br><span class="line">_    <span class="comment">// and make sure their weight is updated properly_</span></span><br><span class="line">_    _for (int32 I=<span class="number">0</span>; I&lt;MontageInstances.<span class="built_in">Num</span>(); ++I)</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">if</span> ( MontageInstances[I] )</span><br><span class="line">       {</span><br><span class="line">          MontageInstances[I]-&gt;<span class="built_in">UpdateWeight</span>(DeltaSeconds);</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAnimInstance::Montage_Advance</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    _<span class="comment">// We're about to tick montages, queue their events to they're triggered after batched anim notifies._</span></span><br><span class="line">_    _bQueueMontageEvents = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MontageInstances.<span class="built_in">IsEmpty</span>())</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_Montage_Advance);</span><br><span class="line"></span><br><span class="line">    _<span class="comment">// go through all montage instances, and update them_</span></span><br><span class="line">_    <span class="comment">// and make sure their weight is updated properly_</span></span><br><span class="line">_    _for (int32 InstanceIndex = <span class="number">0</span>; InstanceIndex &lt; MontageInstances.<span class="built_in">Num</span>(); InstanceIndex++)</span><br><span class="line">    {</span><br><span class="line">       FAnimMontageInstance* <span class="type">const</span> MontageInstance = MontageInstances[InstanceIndex];</span><br><span class="line">       _<span class="comment">// should never be NULL_</span></span><br><span class="line">_       _ensure(MontageInstance);</span><br><span class="line">       <span class="keyword">if</span> (MontageInstance &amp;&amp; MontageInstance-&gt;<span class="built_in">IsValid</span>())</span><br><span class="line">       {</span><br><span class="line">          <span class="type">bool</span> <span class="type">const</span> bUsingBlendedRootMotion = (RootMotionMode == ERootMotionMode::RootMotionFromEverything);</span><br><span class="line">          <span class="type">bool</span> <span class="type">const</span> bNoRootMotionExtraction = (RootMotionMode == ERootMotionMode::NoRootMotionExtraction);</span><br><span class="line"></span><br><span class="line">          _<span class="comment">// Extract root motion if we are using blend root motion (RootMotionFromEverything) or if we are set to extract root _</span></span><br><span class="line">_          <span class="comment">// motion AND we are the active root motion instance. This is so we can make root motion deterministic for networking when_</span></span><br><span class="line">_          <span class="comment">// we are not using RootMotionFromEverything_</span></span><br><span class="line">_          _bool <span class="type">const</span> bExtractRootMotion = !MontageInstance-&gt;<span class="built_in">IsRootMotionDisabled</span>() &amp;&amp; (bUsingBlendedRootMotion || (!bNoRootMotionExtraction &amp;&amp; (MontageInstance == <span class="built_in">GetRootMotionMontageInstance</span>())));</span><br><span class="line"></span><br><span class="line">          FRootMotionMovementParams LocalExtractedRootMotion;</span><br><span class="line">          FRootMotionMovementParams* RootMotionParams = <span class="literal">nullptr</span>;</span><br><span class="line">          <span class="keyword">if</span> (bExtractRootMotion)</span><br><span class="line">          {</span><br><span class="line">             RootMotionParams = (RootMotionMode != ERootMotionMode::IgnoreRootMotion) ? &amp;ExtractedRootMotion : &amp;LocalExtractedRootMotion;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          MontageInstance-&gt;<span class="built_in">MontageSync_PreUpdate</span>();</span><br><span class="line">          MontageInstance-&gt;<span class="built_in">Advance</span>(DeltaSeconds, RootMotionParams, bUsingBlendedRootMotion);</span><br><span class="line"></span><br><span class="line">          _<span class="comment">// If MontageInstances has been modified while executing MontageInstance-&gt;Advance(), MontageInstance is unsafe to_</span></span><br><span class="line">_          <span class="comment">// access further. This happens for example if MontageInstance-&gt;Advance() triggers an anim notify in which the user_</span></span><br><span class="line">_          <span class="comment">// destroys the owning actor which in turn calls UninitializeAnimation(), or when the anim notify causes any montage_</span></span><br><span class="line">_          <span class="comment">// to stop or start playing. We just check here if the current MontageInstance is still safe to access._</span></span><br><span class="line">_          _if (!MontageInstances.<span class="built_in">IsValidIndex</span>(InstanceIndex) || MontageInstances[InstanceIndex] != MontageInstance)</span><br><span class="line">          {</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          MontageInstance-&gt;<span class="built_in">MontageSync_PostUpdate</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DO_CHECK &amp;&amp; WITH_EDITORONLY_DATA &amp;&amp; 0</span></span><br><span class="line">          _<span class="comment">// We need to re-check IsValid() here because Advance() could have terminated this Montage._</span></span><br><span class="line">_          _if (MontageInstance.<span class="built_in">IsValid</span>())</span><br><span class="line">          {</span><br><span class="line">             _<span class="comment">// print blending time and weight and montage name_</span></span><br><span class="line">_             _UE_LOG(LogAnimMontage, Warning, <span class="built_in">TEXT</span>(<span class="string">"%d. Montage (%s), DesiredWeight(%0.2f), CurrentWeight(%0.2f), BlendingTime(%0.2f)"</span>),</span><br><span class="line">                I + <span class="number">1</span>, *MontageInstance-&gt;Montage-&gt;<span class="built_in">GetName</span>(), MontageInstance-&gt;<span class="built_in">GetDesiredWeight</span>(), MontageInstance-&gt;<span class="built_in">GetWeight</span>(),</span><br><span class="line">                MontageInstance-&gt;<span class="built_in">GetBlendTime</span>());</span><br><span class="line">          }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Advance</code> 如何跳跃 <code>DeltaTime</code> 呢？</p>
<p>里面有一个 <code>FMontageSubStepper</code>，一点一点向前移，看会出现什么情况，如果发生了片段的跳转等事件，就用 <code>HandleEvents</code> 处理发生的事件</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FAnimMontageInstance::Advance</span><span class="params">(<span class="type">float</span> DeltaTime, <span class="keyword">struct</span> FRootMotionMovementParams* OutRootMotionParams, <span class="type">bool</span> bBlendRootMotion)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_AnimMontageInstance_Advance);</span><br><span class="line">    <span class="function">FScopeCycleCounterUObject <span class="title">MontageScope</span><span class="params">(Montage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsValid</span>())</span><br><span class="line">    {</span><br><span class="line">       _<span class="comment">// with custom curves, we can't just filter by weight_</span></span><br><span class="line">_       <span class="comment">// also if you have custom curve with longer 0, you'll likely to pause montage during that blending time_</span></span><br><span class="line">_       <span class="comment">// I think that is a bug. It still should move, the weight might come back later. _</span></span><br><span class="line">_       _if (bPlaying)</span><br><span class="line">       {</span><br><span class="line">          <span class="type">const</span> <span class="type">bool</span> bExtractRootMotion = (OutRootMotionParams != <span class="literal">nullptr</span>) &amp;&amp; Montage-&gt;<span class="built_in">HasRootMotion</span>();</span><br><span class="line">          </span><br><span class="line">          DeltaTimeRecord.<span class="built_in">Set</span>(Position, <span class="number">0.f</span>);</span><br><span class="line"></span><br><span class="line">          bDidUseMarkerSyncThisTick = <span class="built_in">CanUseMarkerSync</span>();</span><br><span class="line">          <span class="keyword">if</span> (bDidUseMarkerSyncThisTick)</span><br><span class="line">          {</span><br><span class="line">             MarkersPassedThisTick.<span class="built_in">Reset</span>();</span><br><span class="line">          }</span><br><span class="line">          </span><br><span class="line">          _<span class="comment">/** _</span></span><br><span class="line"><span class="comment">_             Limit number of iterations for performance._</span></span><br><span class="line"><span class="comment">_             This can get out of control if PlayRate is set really high, or there is a hitch, and Montage is looping for example._</span></span><br><span class="line"><span class="comment">_          */</span>_</span><br><span class="line">_          _const int32 MaxIterations = <span class="number">10</span>;</span><br><span class="line">          int32 NumIterations = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          _<span class="comment">/** _</span></span><br><span class="line"><span class="comment">_             If we're hitting our max number of iterations for whatever reason,_</span></span><br><span class="line"><span class="comment">_             make sure we're not accumulating too much time, and go out of range._</span></span><br><span class="line"><span class="comment">_          */</span>_</span><br><span class="line">_          _if (MontageSubStepper.<span class="built_in">GetRemainingTime</span>() &lt; <span class="number">10.f</span>)</span><br><span class="line">          {</span><br><span class="line">             MontageSubStepper.<span class="built_in">AddEvaluationTime</span>(DeltaTime);</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          _<span class="comment">// Gather active anim state notifies if DeltaTime == 0 (happens when TimeDilation is 0.f), so these are not prematurely ended_</span></span><br><span class="line">_          _if (DeltaTime == <span class="number">0.f</span>)</span><br><span class="line">          {</span><br><span class="line">             <span class="built_in">HandleEvents</span>(Position, Position, <span class="literal">nullptr</span>);</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (bPlaying &amp;&amp; MontageSubStepper.<span class="built_in">HasTimeRemaining</span>() &amp;&amp; (++NumIterations &lt; MaxIterations))</span><br><span class="line">          {</span><br><span class="line">             <span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_AnimMontageInstance_Advance_Iteration);</span><br><span class="line"></span><br><span class="line">             <span class="type">const</span> <span class="type">float</span> PreviousSubStepPosition = Position;</span><br><span class="line">             <span class="type">const</span> FBranchingPointMarker* BranchingPointMarker = <span class="literal">nullptr</span>;</span><br><span class="line">             EMontageSubStepResult SubStepResult = MontageSubStepper.<span class="built_in">Advance</span>(Position, &amp;BranchingPointMarker);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (SubStepResult == EMontageSubStepResult::InvalidSection</span><br><span class="line">                || SubStepResult == EMontageSubStepResult::InvalidMontage)</span><br><span class="line">             {</span><br><span class="line">                _<span class="comment">// stop and leave this loop_</span></span><br><span class="line">_                _Stop(<span class="built_in">FAlphaBlend</span>(Montage-&gt;BlendOut, Montage-&gt;BlendOut.<span class="built_in">GetBlendTime</span>() * DefaultBlendTimeMultiplier), <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             }</span><br><span class="line"></span><br><span class="line">             <span class="type">const</span> <span class="type">float</span> SubStepDeltaMove = MontageSubStepper.<span class="built_in">GetDeltaMove</span>();</span><br><span class="line">             DeltaTimeRecord.Delta += SubStepDeltaMove;</span><br><span class="line">             <span class="type">const</span> <span class="type">bool</span> bPlayingForward = MontageSubStepper.<span class="built_in">GetbPlayingForward</span>();</span><br><span class="line"></span><br><span class="line">             _<span class="comment">// If current section is last one, check to trigger a blend out and if it hasn't stopped yet, see if we should stop_</span></span><br><span class="line">_             <span class="comment">// We check this even if we haven't moved, in case our position was different from last frame._</span></span><br><span class="line">_             <span class="comment">// (Code triggered a position jump)._</span></span><br><span class="line">_             _if (!<span class="built_in">IsStopped</span>() &amp;&amp; bEnableAutoBlendOut)</span><br><span class="line">             {</span><br><span class="line">                <span class="type">const</span> int32 CurrentSectionIndex = MontageSubStepper.<span class="built_in">GetCurrentSectionIndex</span>();</span><br><span class="line">                <span class="built_in">check</span>(NextSections.<span class="built_in">IsValidIndex</span>(CurrentSectionIndex));</span><br><span class="line">                <span class="type">const</span> int32 NextSectionIndex = bPlayingForward ? NextSections[CurrentSectionIndex] : PrevSections[CurrentSectionIndex];</span><br><span class="line">                <span class="keyword">if</span> (NextSectionIndex == INDEX_NONE)</span><br><span class="line">                {</span><br><span class="line">                   <span class="type">const</span> <span class="type">float</span> PlayTimeToEnd = MontageSubStepper.<span class="built_in">GetRemainingPlayTimeToSectionEnd</span>(Position);</span><br><span class="line"></span><br><span class="line">                   <span class="type">const</span> <span class="type">bool</span> bCustomBlendOutTriggerTime = (Montage-&gt;BlendOutTriggerTime &gt;= <span class="number">0</span>);</span><br><span class="line">                   <span class="type">const</span> <span class="type">float</span> DefaultBlendOutTime = Montage-&gt;BlendOut.<span class="built_in">GetBlendTime</span>() * DefaultBlendTimeMultiplier;</span><br><span class="line">                   <span class="type">const</span> <span class="type">float</span> BlendOutTriggerTime = bCustomBlendOutTriggerTime ? Montage-&gt;BlendOutTriggerTime : DefaultBlendOutTime;</span><br><span class="line"></span><br><span class="line">                   _<span class="comment">// ... trigger blend out if within blend out time window._</span></span><br><span class="line">_                   _if (PlayTimeToEnd &lt;= FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(BlendOutTriggerTime, UE_KINDA_SMALL_NUMBER))</span><br><span class="line">                   {</span><br><span class="line">                      <span class="type">const</span> <span class="type">float</span> BlendOutTime = bCustomBlendOutTriggerTime ? DefaultBlendOutTime : PlayTimeToEnd;</span><br><span class="line">                      <span class="built_in">Stop</span>(<span class="built_in">FAlphaBlend</span>(Montage-&gt;BlendOut, BlendOutTime), <span class="literal">false</span>);</span><br><span class="line">                   }</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line"></span><br><span class="line">             <span class="type">const</span> <span class="type">bool</span> bHaveMoved = (SubStepResult == EMontageSubStepResult::Moved);</span><br><span class="line">             <span class="keyword">if</span> (bHaveMoved)</span><br><span class="line">             {</span><br><span class="line">                <span class="keyword">if</span> (bDidUseMarkerSyncThisTick)</span><br><span class="line">                {</span><br><span class="line">                   Montage-&gt;MarkerData.<span class="built_in">CollectMarkersInRange</span>(PreviousSubStepPosition, Position, MarkersPassedThisTick, SubStepDeltaMove);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                _<span class="comment">// Extract Root Motion for this time slice, and accumulate it._</span></span><br><span class="line">_                <span class="comment">// IsRootMotionDisabled() can be changed by AnimNotifyState BranchingPoints while advancing, so it needs to be checked here._</span></span><br><span class="line">_                _if (bExtractRootMotion &amp;&amp; AnimInstance.<span class="built_in">IsValid</span>() &amp;&amp; !<span class="built_in">IsRootMotionDisabled</span>())</span><br><span class="line">                {</span><br><span class="line">                   <span class="type">const</span> FTransform RootMotion = Montage-&gt;<span class="built_in">ExtractRootMotionFromTrackRange</span>(PreviousSubStepPosition, Position);</span><br><span class="line">                   <span class="keyword">if</span> (bBlendRootMotion)</span><br><span class="line">                   {</span><br><span class="line">                      _<span class="comment">// Defer blending in our root motion until after we get our slot weight updated_</span></span><br><span class="line">_                      _const <span class="type">float</span> Weight = Blend.<span class="built_in">GetBlendedValue</span>();</span><br><span class="line">                      AnimInstance.<span class="built_in">Get</span>()-&gt;<span class="built_in">QueueRootMotionBlend</span>(RootMotion, Montage-&gt;SlotAnimTracks[<span class="number">0</span>].SlotName, Weight);</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                   {</span><br><span class="line">                      OutRootMotionParams-&gt;<span class="built_in">Accumulate</span>(RootMotion);</span><br><span class="line">                   }</span><br><span class="line"></span><br><span class="line">                   <span class="built_in">UE_LOG</span>(LogRootMotion, Log, <span class="built_in">TEXT</span>(<span class="string">"\tFAnimMontageInstance::Advance ExtractedRootMotion: %s, AccumulatedRootMotion: %s, bBlendRootMotion: %d"</span>)</span><br><span class="line">                      , *RootMotion.<span class="built_in">GetTranslation</span>().<span class="built_in">ToCompactString</span>()</span><br><span class="line">                      , *OutRootMotionParams-&gt;<span class="built_in">GetRootMotionTransform</span>().<span class="built_in">GetTranslation</span>().<span class="built_in">ToCompactString</span>()</span><br><span class="line">                      , bBlendRootMotion</span><br><span class="line">                   );</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line"></span><br><span class="line">             _<span class="comment">// Delegate has to be called last in this loop_</span></span><br><span class="line">_             <span class="comment">// so that if this changes position, the new position will be applied in the next loop_</span></span><br><span class="line">_             <span class="comment">// first need to have event handler to handle it_</span></span><br><span class="line">_             <span class="comment">// Save off position before triggering events, in case they cause a jump to another position_</span></span><br><span class="line">_             _const <span class="type">float</span> PositionBeforeFiringEvents = Position;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(bHaveMoved)</span><br><span class="line">             {</span><br><span class="line">                _<span class="comment">// Save position before firing events._</span></span><br><span class="line">_                _if (!bInterrupted)</span><br><span class="line">                {</span><br><span class="line">                   _<span class="comment">// Must grab a reference on the stack in case "this" is deleted during iteration_</span></span><br><span class="line">_                   _TWeakObjectPtr&lt;UAnimInstance&gt; AnimInstanceLocal = AnimInstance;</span><br><span class="line"></span><br><span class="line">                   <span class="built_in">HandleEvents</span>(PreviousSubStepPosition, Position, BranchingPointMarker);</span><br><span class="line"></span><br><span class="line">                   _<span class="comment">// Break out if we no longer have active montage instances. This may happen when we call UninitializeAnimation from a notify_</span></span><br><span class="line">_                   _if (AnimInstanceLocal.<span class="built_in">IsValid</span>() &amp;&amp; AnimInstanceLocal-&gt;MontageInstances.<span class="built_in">Num</span>() == <span class="number">0</span>)</span><br><span class="line">                   {</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                   }</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line"></span><br><span class="line">             _<span class="comment">// Note that we have to check this even if there is no time remaining, in order to correctly handle loops_</span></span><br><span class="line">_             <span class="comment">// CVar allows reverting to old behavior, in case a project relies on it_</span></span><br><span class="line">_             _if (MontageCVars::bEndSectionRequiresTimeRemaining == <span class="literal">false</span> || MontageSubStepper.<span class="built_in">HasTimeRemaining</span>())</span><br><span class="line">             {</span><br><span class="line">                _<span class="comment">// if we reached end of section, and we were not processing a branching point, and no events has messed with out current position.._</span></span><br><span class="line">_                <span class="comment">// .. Move to next section._</span></span><br><span class="line">_                <span class="comment">// (this also handles looping, the same as jumping to a different section)._</span></span><br><span class="line">_                _if (MontageSubStepper.<span class="built_in">HasReachedEndOfSection</span>() &amp;&amp; !BranchingPointMarker &amp;&amp; (PositionBeforeFiringEvents == Position))</span><br><span class="line">                {</span><br><span class="line">                   _<span class="comment">// Get recent NextSectionIndex in case it's been changed by previous events._</span></span><br><span class="line">_                   _const int32 CurrentSectionIndex = MontageSubStepper.<span class="built_in">GetCurrentSectionIndex</span>();</span><br><span class="line">                   <span class="type">const</span> int32 RecentNextSectionIndex = bPlayingForward ? NextSections[CurrentSectionIndex] : PrevSections[CurrentSectionIndex];</span><br><span class="line">                   <span class="type">const</span> <span class="type">float</span> EndOffset = UE_KINDA_SMALL_NUMBER / <span class="number">2.f</span>; _<span class="comment">//KINDA_SMALL_NUMBER/2 because we use KINDA_SMALL_NUMBER to offset notifies for triggering and SMALL_NUMBER is too small_</span></span><br><span class="line"></span><br><span class="line">_                   _if (RecentNextSectionIndex != INDEX_NONE)</span><br><span class="line">                   {</span><br><span class="line">                      <span class="type">float</span> LatestNextSectionStartTime, LatestNextSectionEndTime;</span><br><span class="line">                      Montage-&gt;<span class="built_in">GetSectionStartAndEndTime</span>(RecentNextSectionIndex, LatestNextSectionStartTime, LatestNextSectionEndTime);</span><br><span class="line"></span><br><span class="line">                      _<span class="comment">// Jump to next section's appropriate starting point (start or end)._</span></span><br><span class="line">_                      _Position = bPlayingForward ? LatestNextSectionStartTime : (LatestNextSectionEndTime - EndOffset);</span><br><span class="line">                      SubStepResult = EMontageSubStepResult::Moved;</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                   {</span><br><span class="line">                      _<span class="comment">// If there is no next section and we've reached the end of this one, exit_</span></span><br><span class="line"></span><br><span class="line">_                      <span class="comment">// Stop playing and clamp position to prevent playing animation data past the end of the current section_</span></span><br><span class="line">_                      <span class="comment">// We already called Stop above if needed, like if bEnableAutoBlendOut is true_</span></span><br><span class="line">_                      _bPlaying = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                      <span class="type">float</span> CurrentSectionStartTime, CurrentSectionEndTime;</span><br><span class="line">                      Montage-&gt;<span class="built_in">GetSectionStartAndEndTime</span>(CurrentSectionIndex, CurrentSectionStartTime, CurrentSectionEndTime);</span><br><span class="line"></span><br><span class="line">                      Position = bPlayingForward ? (CurrentSectionEndTime - EndOffset) : CurrentSectionStartTime;</span><br><span class="line">                      SubStepResult = EMontageSubStepResult::Moved;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                   }</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (SubStepResult == EMontageSubStepResult::NotMoved)</span><br><span class="line">             {</span><br><span class="line">                _<span class="comment">// If it hasn't moved, there is nothing much to do but weight update_</span></span><br><span class="line">_                _break;</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">       </span><br><span class="line">          _<span class="comment">// if we had a ForcedNextPosition set, reset it._</span></span><br><span class="line">_          _ForcedNextToPosition.<span class="built_in">Reset</span>();</span><br><span class="line">          ForcedNextFromPosition.<span class="built_in">Reset</span>();</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ANIM_TRACE_ENABLED</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> FPassedMarker&amp; PassedMarker : MarkersPassedThisTick)</span><br><span class="line">    {</span><br><span class="line">       <span class="built_in">TRACE_ANIM_SYNC_MARKER</span>(AnimInstance.<span class="built_in">Get</span>(), PassedMarker);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    _<span class="comment">// If this Montage has no weight, it should be terminated._</span></span><br><span class="line">_    _if (<span class="built_in">IsStopped</span>() &amp;&amp; (Blend.<span class="built_in">IsComplete</span>()))</span><br><span class="line">    {</span><br><span class="line">       _<span class="comment">// nothing else to do_</span></span><br><span class="line">_       _Terminate();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bInterrupted &amp;&amp; AnimInstance.<span class="built_in">IsValid</span>())</span><br><span class="line">    {</span><br><span class="line">       <span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_AnimMontageInstance_TickBranchPoints);</span><br><span class="line"></span><br><span class="line">       _<span class="comment">// Must grab a reference on the stack in case "this" is deleted during iteration_</span></span><br><span class="line">_       _TWeakObjectPtr&lt;UAnimInstance&gt; AnimInstanceLocal = AnimInstance;</span><br><span class="line"></span><br><span class="line">       _<span class="comment">// Tick all active state branching points_</span></span><br><span class="line">_       _for (int32 Index = <span class="number">0</span>; Index &lt; ActiveStateBranchingPoints.<span class="built_in">Num</span>(); Index++)</span><br><span class="line">       {</span><br><span class="line">          FAnimNotifyEvent&amp; NotifyEvent = ActiveStateBranchingPoints[Index];</span><br><span class="line">          <span class="keyword">if</span> (NotifyEvent.NotifyStateClass)</span><br><span class="line">          {</span><br><span class="line">             <span class="function">FBranchingPointNotifyPayload <span class="title">BranchingPointNotifyPayload</span><span class="params">(AnimInstance-&gt;GetSkelMeshComponent(), Montage, &amp;NotifyEvent, InstanceID)</span></span>;</span><br><span class="line">             NotifyEvent.NotifyStateClass-&gt;<span class="built_in">BranchingPointNotifyTick</span>(BranchingPointNotifyPayload, DeltaTime);</span><br><span class="line"></span><br><span class="line">             _<span class="comment">// Break out if we no longer have active montage instances. This may happen when we call UninitializeAnimation from a notify_</span></span><br><span class="line">_             _if (!<span class="built_in">ValidateInstanceAfterNotifyState</span>(AnimInstanceLocal, NotifyEvent.NotifyStateClass))</span><br><span class="line">             {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><hanla></hanla>总结一下，我们要关注两个核心变量，一是片段 <code>FCompositeSection</code>，二是插槽 <code>FSlotAnimationTrack</code>。</p>
<p>然后要关注往前走是使用 <code>Step</code>，一点点向前跳，中间触发事件，调用完事件后继续向前走。</p>
<p>更新是 <code>FAnimNode_Slot</code> 类，这里面根据名字和时间找出对应的序列帧，然后掉对应的 <code>GetBonePose</code>，传到 <code>Evaluate_AnyThread</code></p>
<h4 id="TwoBoneIK"><a href="#TwoBoneIK" class="headerlink" title="TwoBoneIK"></a>TwoBoneIK</h4><p><hanla></hanla>假设两端骨骼，已知 Target End 一个点，那么在旋转过程中设定一个 JointTarget，就能确定一个平面了</p>
<p>输入，即骨骼 Start Point，Joint Point，End Point。</p>
<p>输出，即新的 End Point 以及用来限制住这些骨骼所在平面的 JointTarget（并不是 Joint 骨骼最终位置，只是为了限制平面）</p>
<blockquote>
<p>这里可以看看其他视频演示，更容易理解</p>
<ol>
<li>先用 Start 和 End 计算出目标向量</li>
<li>再用 Start 和 Joint 计算出所在平面的目标向量</li>
<li>根据上面的两个向量求解出垂直向量（不是垂直于该平面）（使用点乘拿到某个方向上的向量，再相减就得出垂直向量了）</li>
<li>再根据三角形形式，求出夹角</li>
<li>再根据投影的原理，求出骨骼在方向上的位置</li>
<li>该两个方向上的向量加起来就知道 Joint 向量了</li>
<li>这样子方向、旋转值就很容易计算出来了</li>
</ol>
</blockquote>
<p><code>TwoBoneIK</code> 文件中，可以找到 <code>SolveTwoBoneIK</code> 函数</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SolveTwoBoneIK</span><span class="params">(<span class="type">const</span> FVector&amp; RootPos, <span class="type">const</span> FVector&amp; JointPos, <span class="type">const</span> FVector&amp; EndPos, <span class="type">const</span> FVector&amp; JointTarget, <span class="type">const</span> FVector&amp; Effector, FVector&amp; OutJointPos, FVector&amp; OutEndPos, <span class="type">bool</span> bAllowStretching, <span class="type">double</span> StartStretchRatio, <span class="type">double</span> MaxStretchScale)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> LowerLimbLength = (EndPos - JointPos).<span class="built_in">Size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> UpperLimbLength = (JointPos - RootPos).<span class="built_in">Size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SolveTwoBoneIK</span>(RootPos, JointPos, EndPos, JointTarget, Effector, OutJointPos, OutEndPos, UpperLimbLength, LowerLimbLength, bAllowStretching, StartStretchRatio, MaxStretchScale);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SolveTwoBoneIK</span><span class="params">(<span class="type">const</span> FVector&amp; RootPos, <span class="type">const</span> FVector&amp; JointPos, <span class="type">const</span> FVector&amp; EndPos, <span class="type">const</span> FVector&amp; JointTarget, <span class="type">const</span> FVector&amp; Effector, FVector&amp; OutJointPos, FVector&amp; OutEndPos, <span class="type">double</span> UpperLimbLength, <span class="type">double</span> LowerLimbLength, <span class="type">bool</span> bAllowStretching, <span class="type">double</span> StartStretchRatio, <span class="type">double</span> MaxStretchScale)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    _<span class="comment">// This is our reach goal._</span></span><br><span class="line">_    _FVector DesiredPos = Effector;</span><br><span class="line">    FVector DesiredDelta = DesiredPos - RootPos;</span><br><span class="line">    <span class="type">double</span> DesiredLength = DesiredDelta.<span class="built_in">Size</span>();</span><br><span class="line"></span><br><span class="line">    _<span class="comment">// Find lengths of upper and lower limb in the ref skeleton._</span></span><br><span class="line">_    <span class="comment">// Use actual sizes instead of ref skeleton, so we take into account translation and scaling from other bone controllers._</span></span><br><span class="line">_    _double MaxLimbLength = LowerLimbLength + UpperLimbLength;</span><br><span class="line"></span><br><span class="line">    _<span class="comment">// Check to handle case where DesiredPos is the same as RootPos._</span></span><br><span class="line">_    _FVector    DesiredDir;</span><br><span class="line">    <span class="keyword">if</span> (DesiredLength &lt; DOUBLE_KINDA_SMALL_NUMBER)</span><br><span class="line">    {</span><br><span class="line">       DesiredLength = DOUBLE_KINDA_SMALL_NUMBER;</span><br><span class="line">       DesiredDir = <span class="built_in">FVector</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">       DesiredDir = DesiredDelta.<span class="built_in">GetSafeNormal</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _<span class="comment">// Get joint target (used for defining plane that joint should be in)._</span></span><br><span class="line">_    _FVector JointTargetDelta = JointTarget - RootPos;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> JointTargetLengthSqr = JointTargetDelta.<span class="built_in">SizeSquared</span>();</span><br><span class="line"></span><br><span class="line">    _<span class="comment">// Same check as above, to cover case when JointTarget position is the same as RootPos._</span></span><br><span class="line">_    _FVector JointPlaneNormal, JointBendDir;</span><br><span class="line">    <span class="keyword">if</span> (JointTargetLengthSqr &lt; FMath::<span class="built_in">Square</span>(DOUBLE_KINDA_SMALL_NUMBER))</span><br><span class="line">    {</span><br><span class="line">       JointBendDir = <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">       JointPlaneNormal = <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">       JointPlaneNormal = DesiredDir ^ JointTargetDelta;</span><br><span class="line"></span><br><span class="line">       _<span class="comment">// If we are trying to point the limb in the same direction that we are supposed to displace the joint in, _</span></span><br><span class="line">_       <span class="comment">// we have to just pick 2 random vector perp to DesiredDir and each other._</span></span><br><span class="line">_       _if (JointPlaneNormal.<span class="built_in">SizeSquared</span>() &lt; FMath::<span class="built_in">Square</span>(DOUBLE_KINDA_SMALL_NUMBER))</span><br><span class="line">       {</span><br><span class="line">          DesiredDir.<span class="built_in">FindBestAxisVectors</span>(JointPlaneNormal, JointBendDir);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       {</span><br><span class="line">          JointPlaneNormal.<span class="built_in">Normalize</span>();</span><br><span class="line"></span><br><span class="line">          _<span class="comment">// Find the final member of the reference frame by removing any component of JointTargetDelta along DesiredDir._</span></span><br><span class="line">_          <span class="comment">// This should never leave a zero vector, because we've checked DesiredDir and JointTargetDelta are not parallel._</span></span><br><span class="line">_          _JointBendDir = JointTargetDelta - ((JointTargetDelta | DesiredDir) * DesiredDir);</span><br><span class="line">          JointBendDir.<span class="built_in">Normalize</span>();</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _<span class="comment">//UE_LOG(LogAnimationCore, Log, TEXT("UpperLimb : %0.2f, LowerLimb : %0.2f, MaxLimb : %0.2f"), UpperLimbLength, LowerLimbLength, MaxLimbLength);_</span></span><br><span class="line"></span><br><span class="line">_    _if (bAllowStretching)</span><br><span class="line">    {</span><br><span class="line">       <span class="type">const</span> <span class="type">double</span> ScaleRange = MaxStretchScale - StartStretchRatio;</span><br><span class="line">       <span class="keyword">if</span> (ScaleRange &gt; DOUBLE_KINDA_SMALL_NUMBER &amp;&amp; MaxLimbLength &gt; DOUBLE_KINDA_SMALL_NUMBER)</span><br><span class="line">       {</span><br><span class="line">          <span class="type">const</span> <span class="type">double</span> ReachRatio = DesiredLength / MaxLimbLength;</span><br><span class="line">          <span class="type">const</span> <span class="type">double</span> ScalingFactor = (MaxStretchScale - <span class="number">1.0</span>) * FMath::<span class="built_in">Clamp</span>((ReachRatio - StartStretchRatio) / ScaleRange, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">          <span class="keyword">if</span> (ScalingFactor &gt; DOUBLE_KINDA_SMALL_NUMBER)</span><br><span class="line">          {</span><br><span class="line">             LowerLimbLength *= (<span class="number">1.0</span> + ScalingFactor);</span><br><span class="line">             UpperLimbLength *= (<span class="number">1.0</span> + ScalingFactor);</span><br><span class="line">             MaxLimbLength *= (<span class="number">1.0</span> + ScalingFactor);</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    OutEndPos = DesiredPos;</span><br><span class="line">    OutJointPos = JointPos;</span><br><span class="line"></span><br><span class="line">    _<span class="comment">// If we are trying to reach a goal beyond the length of the limb, clamp it to something solvable and extend limb fully._</span></span><br><span class="line">_    _if (DesiredLength &gt;= MaxLimbLength)</span><br><span class="line">    {</span><br><span class="line">       OutEndPos = RootPos + (MaxLimbLength * DesiredDir);</span><br><span class="line">       OutJointPos = RootPos + (UpperLimbLength * DesiredDir);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">       _<span class="comment">// So we have a triangle we know the side lengths of. We can work out the angle between DesiredDir and the direction of the upper limb_</span></span><br><span class="line">_       <span class="comment">// using the sin rule:_</span></span><br><span class="line">_       _const <span class="type">double</span> TwoAB = <span class="number">2.0</span> * UpperLimbLength * DesiredLength;</span><br><span class="line"></span><br><span class="line">       <span class="type">const</span> <span class="type">double</span> CosAngle = (TwoAB != <span class="number">0.0</span>) ? ((UpperLimbLength*UpperLimbLength) + (DesiredLength*DesiredLength) - (LowerLimbLength*LowerLimbLength)) / TwoAB : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">       _<span class="comment">// If CosAngle is less than 0, the upper arm actually points the opposite way to DesiredDir, so we handle that._</span></span><br><span class="line">_       _const <span class="type">bool</span> bReverseUpperBone = (CosAngle &lt; <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">       _<span class="comment">// Angle between upper limb and DesiredDir_</span></span><br><span class="line">_       <span class="comment">// ACos clamps internally so we dont need to worry about out-of-range values here._</span></span><br><span class="line">_       _const <span class="type">double</span> Angle = FMath::<span class="built_in">Acos</span>(CosAngle);</span><br><span class="line"></span><br><span class="line">       _<span class="comment">// Now we calculate the distance of the joint from the root -&gt; effector line._</span></span><br><span class="line">_       <span class="comment">// This forms a right-angle triangle, with the upper limb as the hypotenuse._</span></span><br><span class="line">_       _const <span class="type">double</span> JointLineDist = UpperLimbLength * FMath::<span class="built_in">Sin</span>(Angle);</span><br><span class="line"></span><br><span class="line">       _<span class="comment">// And the final side of that triangle - distance along DesiredDir of perpendicular._</span></span><br><span class="line">_       <span class="comment">// ProjJointDistSqr can't be neg, because JointLineDist must be &lt;= UpperLimbLength because appSin(Angle) is &lt;= 1._</span></span><br><span class="line">_       _const <span class="type">double</span> ProjJointDistSqr = (UpperLimbLength*UpperLimbLength) - (JointLineDist*JointLineDist);</span><br><span class="line">       _<span class="comment">// although this shouldn't be ever negative, sometimes Xbox release produces -0.f, causing ProjJointDist to be NaN_</span></span><br><span class="line">_       <span class="comment">// so now I branch it.                    _</span></span><br><span class="line">_       _double ProjJointDist = (ProjJointDistSqr &gt; <span class="number">0.0</span>) ? FMath::<span class="built_in">Sqrt</span>(ProjJointDistSqr) : <span class="number">0.0</span>;</span><br><span class="line">       <span class="keyword">if</span> (bReverseUpperBone)</span><br><span class="line">       {</span><br><span class="line">          ProjJointDist *= <span class="number">-1.f</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       _<span class="comment">// So now we can work out where to put the joint!_</span></span><br><span class="line">_       _OutJointPos = RootPos + (ProjJointDist * DesiredDir) + (JointLineDist * JointBendDir);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="StrideWraping"><a href="#StrideWraping" class="headerlink" title="StrideWraping"></a>StrideWraping</h4><p><code>FAnimNode_StrideWarping</code> 中计算逻辑在一个函数里，<code>EvaluateSkeletalControl_AnyThread</code> 先算出运动速度，然后调整腿部的骨骼。</p>
<p>他是从 <code>RootMotion</code> 里找到的前进方向</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大腿沿着重力方向，与地面相交的点<hanla></hanla></span></span><br><span class="line">_<span class="comment">// Project Thigh Bone Location on plane made of FootIKLocation and FloorPlaneNormal, along Gravity Dir._</span></span><br><span class="line">_<span class="comment">// This will be the StrideWarpingPlaneOrigin_</span></span><br><span class="line"><span class="type">const</span> FVector StrideWarpingPlaneOrigin = (FMath::<span class="built_in">Abs</span>(ResolvedGravityDirection | ResolvedFloorNormal) &gt; DELTA) ? FMath::<span class="built_in">LinePlaneIntersection</span>(ThighBoneLocation, ThighBoneLocation + ResolvedGravityDirection, IKFootLocation, ResolvedFloorNormal) : IKFootLocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚的位置和给出的点，前进的方向所确定的平面<hanla></hanla></span></span><br><span class="line">_<span class="comment">// Project FK Foot along StrideWarping Plane, this will be our Scale Origin_</span></span><br><span class="line"><span class="type">const</span> FVector ScaleOrigin = FVector::<span class="built_in">PointPlaneProject</span>(IKFootLocation, StrideWarpingPlaneOrigin, ActualStrideDirection);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚的位置投影到上面的平面，可以拿到该长度，为脚步的大小，直接乘以放大系数，得到了目标位置<hanla></hanla></span></span><br><span class="line">_<span class="comment">// Now the ScaleOrigin and IKFootLocation are forming a line parallel to the floor, and we can scale the IK foot._</span></span><br><span class="line"><span class="type">const</span> FVector WarpedLocation = ScaleOrigin + (IKFootLocation - ScaleOrigin) * ActualStrideScale;</span><br><span class="line">Foot.IKFootBoneTransform.<span class="built_in">SetLocation</span>(WarpedLocation);</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>盆骨的移动算法</p>
<img src="/2024/12/05/UE_AnimationSystem/AS4JbSEOQoumuHxjiDCcTadbnEb.png" class="" title="eee">
</blockquote>
<h4 id="Motion-Warping"><a href="#Motion-Warping" class="headerlink" title="Motion Warping"></a>Motion Warping</h4><p><hanla></hanla>动作是带有位移的，但是我们需要根据地形做适应性调整，例如一个动作跨越不同长度的障碍物</p>
<p>实现分为三步：</p>
<p>角色移动在 <code>UCharacterMovementComponent</code> 类中已经由 <code>SimulateRootMotion</code> 定义好一套如何实现的流程了，触发 <code>ConverLocalRootMotionToWorld</code>，计算出 <code>transform</code>，再拿他去使用 <code>CalcAnimRootMotionVelocity</code> 计算速度，影响角色的移动</p>
<p><code>MotionWarpingComponent</code> 类中，在初始化的时候 <code>InitializeComponent</code> 拿到角色的 <code>MovementComponent</code>，绑定 <code>ProcessRootMotionPreConvertToWorld</code>。最终所有事情对移动的影响，就是 <code>ProcessRootMotionPreConvertToWorld</code> 函数</p>
<p><code>MotionWarpingComponent</code> 中，存储着 <code>URootMotionModifer</code> 和 <code>FMotionWarpingTarget</code></p>
<p><code>UAnimNotifyState_MotionWarping</code> 类中，记录了我们在蓝图里看到的 notify，指向的 <code>URootMotionModifier</code>、什么时候触发什么时候结束、触发函数 <code>OnBecomeRelevant</code>，里面就是调一下 <code>AddRootMotionModifier</code></p>
<p><code>URootMotionModifier_SkewWarp::ProcessRootMotion</code> 里有一个计算逻辑</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上一帧到整个扭曲区间结束的时间要移动多少<hanla></hanla></span></span><br><span class="line"><span class="type">const</span> FTransform RootMotionTotal = UMotionWarpingUtilities::<span class="built_in">ExtractRootMotionFromAnimation</span>(Animation.<span class="built_in">Get</span>(), PreviousPosition, EndTime);</span><br><span class="line"><span class="comment">// 上一帧到当前时间要移动多少<hanla></hanla></span></span><br><span class="line"><span class="type">const</span> FTransform RootMotionDelta = UMotionWarpingUtilities::<span class="built_in">ExtractRootMotionFromAnimation</span>(Animation.<span class="built_in">Get</span>(), PreviousPosition, FMath::<span class="built_in">Min</span>(CurrentPosition, EndTime));</span><br></pre></td></tr></tbody></table></figure>

<p><code>RootMotionModifier</code> 根据 <code>WarpTargetName</code> 使用 <code>FindWarpTarget</code> 可以找到对应的 <code>FMotionWarpingTarget</code>，然后就能够使用 <code>GetTargetTransform</code>（蓝图功能里实现？）</p>
<p><code>ProcessRootMotion</code> 里再用 <code>GetTargetLocation</code> 获得世界空间里目的位置，再用 <code>InverseTransformPositionNoScale</code> 转成模型空间的位置，就用 <code>WarpTranslation</code> 计算出要移动的位置，<code>WarpTranslation</code> 这个计算，可以看一看，有一点绕</p>
<h4 id="同步组"><a href="#同步组" class="headerlink" title="同步组"></a>同步组</h4><p>两个时长不一致的动画，按照一定的规则去同步，就是同步组的技术</p>
<h4 id="网络传输方案，带宽，引擎内动画数据格式和压缩"><a href="#网络传输方案，带宽，引擎内动画数据格式和压缩" class="headerlink" title="网络传输方案，带宽，引擎内动画数据格式和压缩"></a>网络传输方案，带宽，引擎内动画数据格式和压缩<hanla></hanla></h4></div></article><aside class="post-widget"><h4>In this article</h4><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#UE-%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F-Copy"><span class="post-toc-number">1.</span> <span class="post-toc-text">UE 动画系统 Copy</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">动画基础<hanla></hanla></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">顶点动画<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">骨骼动画<hanla></hanla></span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">代码部分<hanla></hanla></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">骨骼模型基础信息<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A8%E7%94%BB%E5%BA%8F%E5%88%97"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">动画序列<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A8%E7%94%BB%E4%BF%A1%E6%81%AF"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">动画信息<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E5%8A%A8%E7%94%BB"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">动画蓝图如何更新动画<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%92%99%E5%A4%AA%E5%A5%87%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">蒙太奇源码分析<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#TwoBoneIK"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">TwoBoneIK</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#StrideWraping"><span class="post-toc-number">1.2.7.</span> <span class="post-toc-text">StrideWraping</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Motion-Warping"><span class="post-toc-number">1.2.8.</span> <span class="post-toc-text">Motion Warping</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%8C%E6%AD%A5%E7%BB%84"><span class="post-toc-number">1.2.9.</span> <span class="post-toc-text">同步组<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%96%B9%E6%A1%88%EF%BC%8C%E5%B8%A6%E5%AE%BD%EF%BC%8C%E5%BC%95%E6%93%8E%E5%86%85%E5%8A%A8%E7%94%BB%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%8E%8B%E7%BC%A9"><span class="post-toc-number">1.2.10.</span> <span class="post-toc-text">网络传输方案，带宽，引擎内动画数据格式和压缩</span></a></li></ol></li></ol></li></ol></nav></aside></div><footer class="footer-nav"><div class="footer"><div class="back-top" id="back-top" title="Back to top"><i class="icon icon-chevron-bar-up"></i></div><div class="footer-content"><div><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv">?</span>
PV
</span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">?</span>
UV</span></div>

Copyright ©
2024<span class="time-divide">-</span>2025
Damue.

Power by
<a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>
and
<a href="https://github.com/Cerallin/hexo-theme-yuzu" target="_blank" rel="external nofollow" title="v3.2.5">Theme Yuzu</a>.</div></div></footer>
<script>window.config = {
  url_root: '/',
  meta_path: 'meta.json',
};
</script>
<script src="/js/theme/back-to-top.js"></script>


<script src="/js/theme/clipboard.js"></script>


<script src="/js/theme/loading.js"></script>


<script src="/js/theme/navbar.js"></script>

<script src="/js/theme/search.js"></script>

<script src="/js/theme/toc.js"></script>
<script>window.onload = function () {
  for (const moduleName in Theme) {
    const module = Theme[moduleName];
    module.register();
  }
};</script></div><div class="search-modal" id="search-modal"><div class="card"><div class="card-head"><div class="search-box"><input class="search-input" id="search-input" placeholder="search"><div class="search-button" id="search-button"><div class="icon icon-search"></div></div></div><div class="close-button"><div class="icon icon-x"></div></div></div><div class="card-body"><div class="search-count">search.total<span id="search-count-num">0</span>search result(s) in total.</div><div class="search-result" id="search-result"></div></div></div></div></body></html>